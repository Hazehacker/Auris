#### user

用户表，用于存储用户信息。具体表结构如下：

| 字段名          | 数据类型      | 说明             | 备注                                    |                                 |
| --------------- | ------------- | ---------------- | --------------------------------------- | ------------------------------- |
| id              | bigserial     | 主键             | 自增                                    |                                 |
| (openid)        | varchar       | 微信用户唯一标识 | 数据库暂时不加这个字段                  |                                 |
| username        | varchar(32)   | 用户名           | 唯一                                    |                                 |
| password        | varchar(255)  | 密码             | 不要存明文密码! 存哈希值                |                                 |
| phone           | varchar(11)   | 手机号           |                                         |                                 |
| refresh_token   | varchar(512)  |                  | 仅第一次能获得，数据库永久保存          | 用于后续获取新的 `access_token` |
| email           | varchar(100)  |                  | 邮箱，可用于订阅文章，必须唯一          |                                 |
| avatar          | varchar(1000) | 头像图片路径     |                                         | 可选                            |
| gender          | small int     | 性别             | 约定：0保密/未知 1男 2女                | 可选                            |
| status          | boolean       | 账号状态         | true正常  false锁定                     | 必须                            |
| last_login_time | datetime      | 最后登录时间     | 记录最后登录时间，用于安全审计          | 暂时不加                        |
| role            | small int     | 角色             | 约定：0管理员  1作者 2用户（默认设为2） | 必须                            |
| create_time     | TIMESTAMP(0)  | 创建时间         |                                         |                                 |
| update_time     | TIMESTAMP(0)  | 最后修改时间     |                                         |                                 |



#### playlist

歌单列表

> 和user是一对多关系

| 字段名      | 数据类型     | 说明                 | 备注 |
| ----------- | ------------ | -------------------- | ---- |
| id          | bigserial    |                      |      |
| name        | varchar(100) | 歌单名称             | 必须 |
| sort        | small int    | 用于排序             |      |
| slug        | varchar(255) | URL标识符            |      |
| status      | boolean      | true正常 false已删除 | 必须 |
| create_time | TIMESTAMP(0) |                      |      |
| update_time | TIMESTAMP(0) |                      |      |
| user_id     | bigint       | 所属用户             | 必须 |









#### track

 音轨表，存储所有音频文件的元信息，无论来自本地上传还是在线链接。

> 和user是一对多关系

| 字段名      | 类型                    | 说明                                                         | 备注     |
| ----------- | ----------------------- | ------------------------------------------------------------ | -------- |
| id          | bigserial               | 主键                                                         |          |
| title       | VARCHAR(255)            | 歌曲标题（可编辑）                                           | 必须     |
| artist      | VARCHAR(255)            | 歌手（可编辑）                                               |          |
| album       | VARCHAR(255)            | 专辑（可编辑）                                               |          |
| duration    | INTEGER                 | 时长（秒）                                                   |          |
| file_path   | VARCHAR(2048)           | 本地文件路径 **或** 在线 URL（如 `https://example.com/song.mp3`） | 必须     |
| cover_url   | VARCHAR(512)            | 封面图片 URL 或 Base64/Data URL（可为空）                    |          |
| source_type | ENUM('local', 'online') | 来源类型（`local / online`）                                 | 暂时引入 |
| create_time | timestamp               | 上传/添加时间                                                |          |

> ✅ 支持“编辑音乐信息”：前端可直接更新 `title`, `artist`, `album`, `cover_url`
>  ✅ “自动解析 ID3 标签”：解析后填入字段，并保留原始数据在 `metadata_json`



> ##### ✅ **保留 `source_type` 的理由**
>
> 1. **行为差异处理**
>
> - **本地文件**（`local`）：
>   - 文件路径可能是浏览器的 `FileSystemHandle`、临时 Blob URL 或 IndexedDB 中的引用。
>   - 无法直接通过 HTTP 请求播放（受 CORS / 安全策略限制）。
>   - 可能需要特殊加载逻辑（如通过 `<input type="file">` 或 File System Access API）。
> - **在线资源**（`online`）：
>   - 是一个可直接 `fetch()` 或 `<audio src="...">` 加载的 URL。
>   - 可能支持流式播放、预加载等。
>
> > 🎯 有了 `source_type`，播放器在加载音频时可以走不同的逻辑分支，避免错误尝试用 `<audio>` 直接播放本地文件路径（会失败）。
>
> ##### 2. **UI/UX 区分**
>
> - 在音乐库中，你可以给用户显示图标区分：“本地歌曲” vs “网络音频”。
> - 删除逻辑也可能不同：本地文件只是移除数据库记录；在线链接可能允许“失效检测”。
>
> 3. **未来扩展清晰**
>
> - 后期若加入“视频转音频”、“播客订阅”等，可扩展为 `ENUM('local', 'online', 'youtube', 'podcast')`。
>
> ------
>
> ❌ **可以省略的情况**
>
> 如果你决定 **统一抽象所有音频为“可播放 URL”**，例如：
>
> - 本地上传的文件 → 立即转为 `URL.createObjectURL(file)`，并将该 **Blob URL 存入 `file_path`**
> - 所有播放都通过 `<audio src={file_path}>` 实现
>
> 那么：
>
> - 从播放器角度看，**所有资源都是“URL”**，无需区分来源
> - `source_type` 就成了冗余字段
>
> > ⚠️ 但注意：**Blob URL 是临时的**！页面刷新后失效。
> >  如果你希望“关闭页面后还能继续播放之前添加的本地歌曲”，就必须持久化原始 File 对象（如通过 File System Access API 保存 handle），这时又需要知道它是 `local` 类型以便重新读取。
>
> ------
>
> 🔍 推荐方案（平衡简洁与健壮）
>
> ✅ **保留 `source_type` 字段**，原因如下：
>
> | 场景                                | 是否需要 `source_type`       |
> | ----------------------------------- | ---------------------------- |
> | 页面刷新后恢复本地歌曲播放          | ✅ 需要（否则 Blob URL 失效） |
> | 支持拖拽添加本地文件 + 粘贴在线链接 | ✅ 需要区分处理               |
> | 未来想加“仅显示本地歌曲”筛选        | ✅ 需要                       |
> | 纯内存播放（不持久化）              | ❌ 可省略                     |
>
> > 💡 即使你当前用 Blob URL，也可以把 `source_type = 'local'` 作为标记，提示“这个 URL 是临时的，原始文件需重新获取”。
>
> ------
>
> ### 🛠 替代方案（不用 ENUM）
>
> 如果你不想用数据库 ENUM（某些环境不支持），可以用：
>
> ```
> // 前端常量
> const SOURCE_TYPES = {
>   LOCAL: 'local',
>   ONLINE: 'online'
> } as const;
> ```
>
> 数据库字段仍为 `TEXT`，但语义明确。
>
> ------
>
> ##### ✅ 结论
>
> > **建议保留 `source_type` 字段**。
> >  它虽然看似简单，但在**持久化、播放逻辑、错误处理、用户体验**上提供关键区分，且几乎无维护成本。





#### playlist_tracks

歌单-歌曲关联表，歌单与歌曲的灵活绑定。

> 多对多关系

| 字段名      | 类型         | 说明                               | 备注     |
| ----------- | ------------ | ---------------------------------- | -------- |
| id          | bigserial    | 主键                               |          |
| playlist_id | int8         | 外键 → `playlists.id`              |          |
| track_id    | int8         | 外键 → `tracks.id`                 |          |
| order_index | int          | 歌曲在歌单中的顺序（用于拖拽排序） | 考虑加入 |
| create_time | TIMESTAMP(0) | 添加时间                           |          |

> ✅ 支持“添加/移除歌曲”、“点击歌单播放全部”
>  ✅ 通过 `order_index` 实现自定义播放顺序







#### play_history

播放历史（可选，后期扩展用）

> 记录用户最近播放的歌曲，用于“每日推荐”等。

| 字段名        | 类型         | 说明               | 备注 |
| ------------- | ------------ | ------------------ | ---- |
| id            | bigserial    | 主键               |      |
| track_id      | int8         | 外键 → `tracks.id` |      |
| listened_time | TIMESTAMP(0) | 播放时间           |      |
| user_id       | int8         | 所属用户           |      |







#### lyrics

歌词表（中期功能）

> 存储 `.lrc` 格式歌词，与歌曲一对一或一对多（多语言）。

| 字段名      | 类型          | 说明                  |
| ----------- | ------------- | --------------------- |
| id          | bigserial     | 主键                  |
| track_id    | int8          | 外键 → `tracks.id`    |
| language    | VARCHAR(10)   | 如 'zh', 'en'（可选） |
| content     | varchar(2048) | LRC 文本内容          |
| create_time | TIMESTAMP(0)  | 上传时间              |

> ✅ 支持“手动上传 .lrc 文件”





#### 使用PostgreSQL

> 这个项目**更推荐 PostgreSQL 而不是 MySQL**，主要基于以下 **5 个关键理由**，这些理由直接对应你项目中的实际需求和数据库设计：
>
> ------
>
> #### ✅ 1. **原生 JSON/JSONB 支持 —— 完美匹配 `metadata_json` 字段**
>
> - 你的 `track` 表中有一个 `metadata_json` 字段，用于存储 ID3 元数据（如艺术家、专辑、年份等原始信息）。
> - **PostgreSQL** 提供 `JSONB` 类型：
>   - 支持**索引**（可快速查找“所有2000年发行的歌曲”）
>   - 支持**高效查询与更新**（如 `metadata_json->>'year' = '2000'`）
>   - 存储为二进制格式，性能优于纯文本
> - **MySQL** 虽有 `JSON` 类型，但：
>   - 查询语法复杂
>   - 索引支持有限（需生成虚拟列）
>   - 更新整个 JSON 文档效率低
>
> > 📌 你明确要“保留原始 ID3 数据用于恢复/调试”——PostgreSQL 的 JSONB 是为此类场景量身打造的。
>
> ------
>
> #### ✅ 2. **真正的枚举（ENUM）与类型安全**
>
> - 你的表中有多处枚举字段：
>
>   - `source_type`（'local' / 'online'）
>   - `gender`（0/1/2）
>   - `status`（0正常 / 1删除）
>
> - **PostgreSQL** 支持自定义 `ENUM` 类型：
>
>   ```sql
>   CREATE TYPE source_type_enum AS ENUM ('local', 'online');
>   ```
>
>   - 数据库层面强制约束，防止非法值（如 `source_type = 'cloud'`）
>   - 语义清晰，文档友好
>
> - **MySQL** 的 `ENUM` 是字符串列表，但：
>
>   - 修改枚举值需 `ALTER TABLE`（锁表风险）
>   - 内部以整数存储，调试时易混淆
>   - 不支持跨表复用
>
> ------
>
> #### ✅ 3. **更严格的 ACID 与默认隔离级别**
>
> - 歌单操作（如“添加多首歌到歌单”）需要事务保证一致性。
> - **PostgreSQL 默认使用 `READ COMMITTED` + 快照隔离**，避免脏读、不可重复读。
> - **MySQL（InnoDB）虽也支持事务**，但：
>   - 默认隔离级别行为在不同版本中有差异
>   - 在高并发下更容易出现幻读（除非手动升级到 `REPEATABLE READ` 或 `SERIALIZABLE`）
> - 对于“小团队自用但要求稳定”的项目，PG 的一致性模型更可靠、更可预测。
>
> ------
>
> #### ✅ 4. **更强大的扩展性与未来兼容性**
>
> 即使当前是小型项目，但你的路线图包含：
>
> - 歌词同步（`.lrc` 解析）
> - 播放历史 → 个性化推荐
> - 可能引入全文搜索（搜歌曲/歌手）
>
> **PostgreSQL 生态优势明显**：
>
> - 内置全文搜索（`tsvector`）
> - 支持向量存储（通过 `pgvector` 插件，未来做推荐系统）
> - 支持地理空间（PostGIS，万一以后加“音乐地点标签”？）
> - 支持逻辑复制、物化视图等高级功能
>
> 而 MySQL 在这些领域要么缺失，要么需依赖外部工具。
>
> ------
>
> #### ✅ 5. **开发体验更现代、ORM 友好**
>
> - 当前主流 Node.js / TypeScript ORM（如 **Prisma**, **Drizzle ORM**, **TypeORM**）对 PostgreSQL 的支持**更完整、更优先**。
> - Prisma 的 `json`、`enum`、`uuid` 等类型在 PG 上开箱即用，在 MySQL 上常需额外配置或降级处理。
> - 错误提示、类型推导、迁移工具（如 `pg_dump` vs `mysqldump`）整体更一致可靠。
>
> ------
>
> #### ❌ 那 MySQL 有什么优势？为什么不用？
>
> | MySQL 优势           | 是否适用于本项目？             |
> | -------------------- | ------------------------------ |
> | 安装简单、资源占用低 | ✅ 但 Docker 下差异极小         |
> | 被广泛使用           | ⚠️ 但 PG 在新项目中已成主流     |
> | 云服务便宜           | ⚠️ Neon、Supabase 等提供免费 PG |
>
> → **这些优势在你的“小团队自用 Web 音乐播放器”场景中并不关键**，而 PostgreSQL 的**数据模型表达力、一致性、扩展性**才是核心价值。
>
> ------
>
> #### ✅ 结论
>
> > **PostgreSQL 更适合你的项目，因为它：**
> >
> > 1. 原生高效支持 JSON 元数据（`metadata_json`）
> > 2. 提供安全、灵活的枚举类型
> > 3. 事务模型更可靠
> > 4. 为未来功能（搜索、推荐）预留空间
> > 5. 与现代前端/全栈技术栈（TS + Prisma）无缝集成
>
> **选 PostgreSQL，就是为项目的长期可维护性和功能演进打下坚实基础。**